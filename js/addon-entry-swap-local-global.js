(window["webpackJsonpGUI"] = window["webpackJsonpGUI"] || []).push([["addon-entry-swap-local-global"],{

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/swap-local-global/style.css":
/*!*********************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/swap-local-global/style.css ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sa-swap-local-global-hint {\n  padding-bottom: 1rem;\n}\n.sa-swap-local-global-stage {\n  /* resolves scratch class style conflict */\n  display: block;\n}\n", ""]);

// exports


/***/ }),

/***/ "./src/addons/addons/swap-local-global/_runtime_entry.js":
/*!***************************************************************!*\
  !*** ./src/addons/addons/swap-local-global/_runtime_entry.js ***!
  \***************************************************************/
/*! exports provided: resources */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resources", function() { return resources; });
/* harmony import */ var _userscript_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userscript.js */ "./src/addons/addons/swap-local-global/userscript.js");
/* harmony import */ var _css_loader_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! css-loader!./style.css */ "./node_modules/css-loader/index.js!./src/addons/addons/swap-local-global/style.css");
/* harmony import */ var _css_loader_style_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_style_css__WEBPACK_IMPORTED_MODULE_1__);
/* generated by pull.js */


var resources = {
  "userscript.js": _userscript_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "style.css": _css_loader_style_css__WEBPACK_IMPORTED_MODULE_1___default.a
};

/***/ }),

/***/ "./src/addons/addons/swap-local-global/userscript.js":
/*!***********************************************************!*\
  !*** ./src/addons/addons/swap-local-global/userscript.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* harmony default export */ __webpack_exports__["default"] = (function (_x) {
  return _ref2.apply(this, arguments);
});

function _ref2() {
  _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var addon, msg, console, ScratchBlocks, vm, getTargetName, getTargetsThatUseVariable, getTargetsWithLocalVariableNamed, getVmVariable, isStageSelected, deleteVariableWithoutDeletingBlocks, syncBlockVariableNameWithActualVariableName, _undoRedoPreserveStateCallback, finishUndoRedoState, customUndoVarDelete, customUndoVarCreate, flushBlocklyEventQueue, beginPreservingState, convertVariable, canUserUseCloudVariables, addMoreOptionsToPrompt, originalRenameVariable;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            addon = _ref.addon, msg = _ref.msg, console = _ref.console;
            _context.next = 3;
            return addon.tab.traps.getBlockly();

          case 3:
            ScratchBlocks = _context.sent;
            vm = addon.tab.traps.vm;

            getTargetName = function getTargetName(target) {
              if (target.isStage) {
                // Stage always has an internal name of "Stage", but we want a translatable name
                return ScratchBlocks.ScratchMsgs.translate("SENSING_OF_STAGE", "Stage");
              }

              return target.getName();
            };

            getTargetsThatUseVariable = function getTargetsThatUseVariable(id) {
              return vm.runtime.targets.filter(function (target) {
                return target.isOriginal;
              }).filter(function (target) {
                return Object.values(target.blocks._blocks).find(function (block) {
                  return block.fields.LIST && block.fields.LIST.id === id || block.fields.VARIABLE && block.fields.VARIABLE.id === id;
                });
              });
            }; // https://github.com/LLK/scratch-vm/blob/7c6f1e44fb0a9b0d0279225cd4c62fbe59b6af54/src/engine/blocks.js#L388-L394


            getTargetsWithLocalVariableNamed = function getTargetsWithLocalVariableNamed(name, type) {
              return vm.runtime.targets.filter(function (target) {
                return target.isOriginal && target.lookupVariableByNameAndType(name, type, true);
              });
            };

            getVmVariable = function getVmVariable(id) {
              return vm.editingTarget.lookupVariableById(id);
            };

            isStageSelected = function isStageSelected() {
              return vm.editingTarget.isStage;
            };

            deleteVariableWithoutDeletingBlocks = function deleteVariableWithoutDeletingBlocks(workspace, variable) {
              // variable can be an ID or an actual Blockly variable object
              if (typeof variable === "string") {
                variable = workspace.getVariableById(variable);
              }

              workspace.variableMap_.deleteVariable(variable);
            };

            syncBlockVariableNameWithActualVariableName = function syncBlockVariableNameWithActualVariableName(workspace, id) {
              var variable = workspace.getVariableById(id);

              var _iterator = _createForOfIteratorHelper(workspace.getAllBlocks()),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var block = _step.value;
                  block.updateVarName(variable);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            };

            _undoRedoPreserveStateCallback = null;

            finishUndoRedoState = function finishUndoRedoState() {
              if (_undoRedoPreserveStateCallback) {
                _undoRedoPreserveStateCallback();

                _undoRedoPreserveStateCallback = null;
              }
            }; // https://github.com/LLK/scratch-blocks/blob/0d6012df1e18e66d82c1247f1f6d772a719982a7/core/variable_events.js#L194


            customUndoVarDelete = function customUndoVarDelete(forward) {
              var workspace = this.getEventWorkspace_();

              if (forward) {
                _undoRedoPreserveStateCallback = beginPreservingState(workspace, this.varId);
                deleteVariableWithoutDeletingBlocks(workspace, this.varId);
              } else {
                workspace.createVariable(this.varName, this.varType, this.varId, this.isLocal, this.isCloud);
                finishUndoRedoState();
              }
            }; // https://github.com/LLK/scratch-blocks/blob/0d6012df1e18e66d82c1247f1f6d772a719982a7/core/variable_events.js#L131


            customUndoVarCreate = function customUndoVarCreate(forward) {
              var workspace = this.getEventWorkspace_();

              if (forward) {
                workspace.createVariable(this.varName, this.varType, this.varId, this.isLocal, this.isCloud);
                finishUndoRedoState();
              } else {
                _undoRedoPreserveStateCallback = beginPreservingState(workspace, this.varId);
                deleteVariableWithoutDeletingBlocks(workspace, this.varId);
              }
            };

            flushBlocklyEventQueue = function flushBlocklyEventQueue() {
              return ScratchBlocks.Events.fireNow_();
            };

            beginPreservingState = function beginPreservingState(workspace, id) {
              // oldMonitorState is an instance of https://github.com/LLK/scratch-vm/blob/develop/src/engine/monitor-record.js or undefined
              var oldMonitorState = vm.runtime._monitorState.get(id);

              var oldVmVariable = getVmVariable(id);
              return function () {
                flushBlocklyEventQueue();
                var newVmVariable = getVmVariable(id);

                if (newVmVariable) {
                  newVmVariable.value = oldVmVariable.value;
                } // Update the variable monitor (state is maintained separately)


                if (oldMonitorState) {
                  if (oldMonitorState.visible) {
                    vm.runtime.monitorBlocks.changeBlock({
                      id: id,
                      element: "checkbox",
                      value: true
                    });
                  }

                  var isLocal = !vm.runtime.getTargetForStage().variables[id];
                  var newMonitorState = oldMonitorState;

                  if (isLocal) {
                    var target = vm.editingTarget;
                    newMonitorState = newMonitorState.set("targetId", target.id);
                    newMonitorState = newMonitorState.set("spriteName", target.getName());
                  } else {
                    newMonitorState = newMonitorState.set("targetId", null);
                    newMonitorState = newMonitorState.set("spriteName", null);
                  }

                  if (newVmVariable.name !== oldVmVariable.name) {
                    var monitorBlocks = vm.runtime.monitorBlocks;
                    var block = monitorBlocks.getBlock(id);

                    if (block) {
                      newMonitorState = newMonitorState.set("params", monitorBlocks._getBlockParams(block));
                    }
                  }

                  vm.runtime.requestAddMonitor(newMonitorState);
                }

                if (newVmVariable.name !== oldVmVariable.name) {
                  syncBlockVariableNameWithActualVariableName(workspace, id);
                }
              };
            };

            convertVariable = function convertVariable(oldBlocklyVariable, newLocal, newCloud) {
              var CLOUD_PREFIX = "â˜ ";
              var name = oldBlocklyVariable.name;
              var id = oldBlocklyVariable.getId();
              var type = oldBlocklyVariable.type;
              var isLocal = oldBlocklyVariable.isLocal;
              var isCloud = oldBlocklyVariable.isCloud;

              if (isLocal === newLocal && isCloud === newCloud) {
                return;
              } // Cloud variables must always be global


              if (newCloud && newLocal) {
                alert(msg("cant-convert-cloud"));
                return;
              }

              var editingTarget = vm.editingTarget;

              if (isLocal !== newLocal) {
                if (newLocal) {
                  // Stage cannot have local variables
                  if (isStageSelected()) {
                    alert(msg("cant-convert-stage"));
                    return;
                  } // Variables used by unfocused sprites cannot be made local
                  // That includes cases where the variable is used by multiple sprites and where it's only used by an unfocused sprite


                  var targets = getTargetsThatUseVariable(id);

                  if (!targets.every(function (i) {
                    return i === editingTarget;
                  })) {
                    if (targets.length > 1) {
                      alert(msg("cant-convert-to-local", {
                        sprites: targets.map(getTargetName).join(", ")
                      }));
                    } else {
                      alert(msg("cant-convert-used-elsewhere", {
                        sprite: getTargetName(targets[0])
                      }));
                    }

                    return;
                  }
                } else {
                  // Global variables must not conflict with any local variables
                  var _targets = getTargetsWithLocalVariableNamed(name, type).filter(function (target) {
                    return target !== editingTarget;
                  });

                  if (_targets.length > 0) {
                    alert(msg("cant-convert-conflict", {
                      sprites: _targets.map(getTargetName).join(", ")
                    }));
                    return;
                  }
                }
              }

              var newName = name;

              if (isCloud !== newCloud) {
                if (newCloud) {
                  newName = CLOUD_PREFIX + name;
                } else if (name.startsWith(CLOUD_PREFIX)) {
                  newName = name.replace(CLOUD_PREFIX, "");
                }
              }

              var workspace = oldBlocklyVariable.workspace;
              var finishPreservingState = beginPreservingState(workspace, id);
              ScratchBlocks.Events.setGroup(true);

              try {
                deleteVariableWithoutDeletingBlocks(workspace, oldBlocklyVariable);
                workspace.createVariable(newName, type, id, newLocal, newCloud);
              } finally {
                ScratchBlocks.Events.setGroup(false);
              } // 2 items will be added to the queue: a variable create and delete
              // We override their undo handlers to make undo/redo work properly


              flushBlocklyEventQueue();
              var stack = workspace.undoStack_;
              var createEvent = stack[stack.length - 1];
              var deleteEvent = stack[stack.length - 2];

              if (createEvent instanceof ScratchBlocks.Events.VarCreate && deleteEvent instanceof ScratchBlocks.Events.VarDelete) {
                createEvent.run = customUndoVarCreate;
                deleteEvent.run = customUndoVarDelete;
              }

              finishPreservingState();
            };

            canUserUseCloudVariables = function canUserUseCloudVariables() {
              var blocksWrapper = document.querySelector('[class^="gui_blocks-wrapper_"]');
              var internalNode = blocksWrapper[addon.tab.traps.getInternalKey(blocksWrapper)];

              while (true) {
                var _internalNode$stateNo, _internalNode$stateNo2;

                if (!internalNode) {
                  return false;
                }

                var canUseCloud = (_internalNode$stateNo = internalNode.stateNode) === null || _internalNode$stateNo === void 0 ? void 0 : (_internalNode$stateNo2 = _internalNode$stateNo.props) === null || _internalNode$stateNo2 === void 0 ? void 0 : _internalNode$stateNo2.canUseCloud;

                if (typeof canUseCloud === "boolean") {
                  return canUseCloud;
                }

                internalNode = internalNode.child;
              }
            };

            addMoreOptionsToPrompt = function addMoreOptionsToPrompt(variable) {
              if (addon.self.disabled) {
                return;
              }

              var promptBody = document.querySelector('[class^="prompt_body_"]');

              if (!promptBody) {
                return;
              }

              var headerTitle = promptBody.parentElement.querySelector('[class^="modal_header-item_"]');

              if (headerTitle) {
                if (variable.type === "") {
                  headerTitle.textContent = msg("edit-variable-header");
                } else {
                  headerTitle.textContent = msg("edit-list-header");
                }
              }

              var root = document.createElement("div");
              addon.tab.displayNoneWhileDisabled(root);

              var createLabeledInput = function createLabeledInput(text, value) {
                var outer = document.createElement("label");
                var input = document.createElement("input");

                if (value === "checkbox") {
                  input.type = "checkbox";
                } else {
                  input.name = "variableScopeOption";
                  input.type = "radio";
                  input.value = value;
                }

                outer.appendChild(input);
                var label = document.createElement("span");
                label.textContent = text;
                outer.appendChild(label);
                return {
                  outer: outer,
                  label: label,
                  input: input
                };
              };

              var promptDisabledClass = addon.tab.scratchClass("prompt_disabled-label");
              var noLocalsInStageSection = document.createElement("div");
              noLocalsInStageSection.className = addon.tab.scratchClass("prompt_info-message", "prompt_cloud-option", {
                others: "sa-swap-local-global-stage"
              });
              noLocalsInStageSection.appendChild(Object.assign(document.createElement("span"), {
                textContent: addon.tab.scratchMessage("gui.gui.variablePromptAllSpritesMessage")
              }));
              var scopeSection = document.createElement("div");
              scopeSection.className = addon.tab.scratchClass("prompt_options-row", "prompt_cloud-option");
              var forAllSprites = createLabeledInput(addon.tab.scratchMessage("gui.gui.variableScopeOptionAllSprites"), "global");
              var forThisSpriteOnly = createLabeledInput(addon.tab.scratchMessage("gui.gui.variableScopeOptionSpriteOnly"), "local");
              forAllSprites.input.checked = !variable.isLocal;
              forThisSpriteOnly.input.checked = variable.isLocal;
              scopeSection.appendChild(forAllSprites.outer);
              scopeSection.appendChild(forThisSpriteOnly.outer);
              var cloudSection = document.createElement("div");
              cloudSection.className = addon.tab.scratchClass("prompt_cloud-option");
              var cloudCheckbox = createLabeledInput(addon.tab.scratchMessage("gui.gui.cloudVariableOption"), "checkbox");
              cloudCheckbox.input.checked = variable.isCloud;

              if (!vm.runtime.canAddCloudVariable() && !variable.isCloud) {
                cloudCheckbox.input.disabled = true;
                cloudSection.classList.add(promptDisabledClass);
              }

              cloudSection.appendChild(cloudCheckbox.outer);

              var updateDisabledInputs = function updateDisabledInputs() {
                var thisSpriteOnlyDisabled = cloudCheckbox.input.checked;
                forThisSpriteOnly.input.disabled = thisSpriteOnlyDisabled;
                forThisSpriteOnly.label.classList.toggle(promptDisabledClass, thisSpriteOnlyDisabled);

                if (thisSpriteOnlyDisabled) {
                  forAllSprites.input.click();
                }
              };

              cloudCheckbox.input.addEventListener("change", updateDisabledInputs);
              updateDisabledInputs();
              var isAnythingConfigurable = false;

              if (isStageSelected()) {
                root.appendChild(noLocalsInStageSection);
              } else {
                isAnythingConfigurable = true;
                root.appendChild(scopeSection);
              }

              if (variable.type === "" && canUserUseCloudVariables()) {
                isAnythingConfigurable = true;
                root.appendChild(cloudSection);
              }

              if (isAnythingConfigurable) {
                root.prepend(Object.assign(document.createElement("div"), {
                  textContent: msg("edit"),
                  className: "sa-swap-local-global-hint"
                }));
              }

              promptBody.insertBefore(root, promptBody.lastChild);
              return {
                isLocal: function isLocal() {
                  return forThisSpriteOnly.input.checked;
                },
                isCloud: function isCloud() {
                  return cloudCheckbox.input.checked;
                }
              };
            }; // https://github.com/LLK/scratch-blocks/blob/c5014f61e2e538e99601a9e0cb39e339e44c3910/core/variables.js#L470


            originalRenameVariable = ScratchBlocks.Variables.renameVariable;

            ScratchBlocks.Variables.renameVariable = function (workspace, variable, opt_callback) {
              var ret = originalRenameVariable.call(this, workspace, variable, function () {
                if (opt_callback) {
                  opt_callback.apply(void 0, arguments);
                }

                if (!addon.self.disabled && prompt) {
                  convertVariable(variable, prompt.isLocal(), prompt.isCloud());
                }
              });
              var prompt = addMoreOptionsToPrompt(variable);
              return ret;
            };

            addon.tab.createBlockContextMenu(function (items, block) {
              if (!addon.self.disabled && (block.getCategory() === "data" || block.getCategory() === "data-lists")) {
                var variable = block.workspace.getVariableById(block.getVars()[0]);

                if (variable) {
                  if (items.length > 0) {
                    if (items[0].text === ScratchBlocks.ScratchMsgs.translate("RENAME_VARIABLE")) {
                      items[0].text = msg("edit-variable-option");
                    } else if (items[0].text === ScratchBlocks.ScratchMsgs.translate("RENAME_LIST")) {
                      items[0].text = msg("edit-list-option");
                    }
                  }

                  items.push({
                    enabled: true,
                    separator: true,
                    text: msg("to-".concat(variable.isLocal ? "global" : "local")),
                    callback: function callback() {
                      return convertVariable(variable, !variable.isLocal, variable.isCloud);
                    }
                  });
                }
              }

              return items;
            }, {
              flyout: true,
              blocks: true
            });

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref2.apply(this, arguments);
}

/***/ })

}]);
//# sourceMappingURL=addon-entry-swap-local-global.js.map